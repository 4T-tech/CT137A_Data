module ds1302_io(
	input           clk,
	input           rst_n,
	output          ds1302_ce,			//ds1302的ce片选脚
	output          ds1302_sclk,		//ds1302的时钟管脚
	inout           ds1302_io,			//ds1302的数据管脚
	input           cmd_read,			//读命令
	input           cmd_write,			//写命令
	output          cmd_read_ack,		
	output          cmd_write_ack,
	input[7:0]      read_addr,			//读数据的地址
	input[7:0]      write_addr,			//写数据的地址
	output reg[7:0] read_data,			//读到的数据
	input[7:0]      write_data			//要写的数据
);

localparam S_IDLE         =  0;		//空闲状态
localparam S_CE_HIGH      =  1;		//片选置高状态
localparam S_READ         =  2;		//读操作过渡状态
localparam S_READ_ADDR    =  3;		//写入要读的地址
localparam S_READ_DATA    =  4;		//读数据状态
localparam S_WRITE        =  5;		//写操作过渡状态
localparam S_WRITE_ADDR   =  6;		//写入要写的地址
localparam S_WRITE_DATA   =  7;		//写数据状态
localparam S_CE_LOW       =  8;		//片选拉低状态
localparam S_ACK          =  9;		//流程结束反馈状态

reg[3:0] state, next_state;
reg[19:0] delay_cnt;
reg wr_req;							//SPI读写请求触发信号，实例化SPI模块
wire wr_ack;						//SPI操作结束信号，实例化SPI模块
reg CS_reg;							//暂存片选信号，实例化SPI模块
wire DCLK;							//SPI的时钟线，实例化SPI模块
wire MOSI;							//SPI的MOSI，实例化SPI模块
wire MISO;							//SPI的MISO，实例化SPI模块
reg[7:0] send_data;					//暂存需要写入的数据，实例化SPI模块
wire[7:0] data_rec;					//暂存读到的数据，实例化SPI模块
reg ds1302_io_dir;					//数据线方向，=0写输出（高阻态），=1读输入

assign ds1302_io = ~ds1302_io_dir ? MOSI : 1'bz;	//数据管脚方向，输出或者高阻态
assign MISO = ds1302_io;							//把MISO和MOSI合并到di1302_io上，变成三线SPI
//assign ds1302_ce = CS_reg;
assign ds1302_sclk = DCLK;
assign cmd_read_ack = (state == S_ACK);
assign cmd_write_ack = (state == S_ACK);

//ds1302数据流状态机
always@(posedge clk or posedge rst_n)
begin
	if(rst_n)
		state <= S_IDLE;
	else
		state <= next_state;
end

always@(*)
begin
	case(state)
		S_IDLE:		//空闲
			if(cmd_read || cmd_write)	//有读或写的命令
				next_state <= S_CE_HIGH;
			else
				next_state <= S_IDLE;
		S_CE_HIGH:		//片选拉高
			if(delay_cnt == 20'd255)	//延时
				next_state <= cmd_read ? S_READ : S_WRITE;	//判断读或写
			else
				next_state <= S_CE_HIGH;
		S_READ:
			next_state <= S_READ_ADDR;
		S_READ_ADDR:		//写入要读的地址
			if(wr_ack)		//传输结束
				next_state <= S_READ_DATA;
			else
				next_state <= S_READ_ADDR;
		S_READ_DATA:		//读数据
			if(wr_ack)
				next_state <= S_ACK;
			else
				next_state <= S_READ_DATA;
		S_WRITE:
			next_state <= S_WRITE_ADDR;
		S_WRITE_ADDR:		//写入要写的地址
			if(wr_ack)
				next_state <= S_WRITE_DATA;
			else
				next_state <= S_WRITE_ADDR;
		S_WRITE_DATA:		//写数据
			if(wr_ack)
				next_state <= S_ACK;
			else
				next_state <= S_WRITE_DATA;
		S_ACK:				//准备结束
			next_state <= S_CE_LOW;
		S_CE_LOW:
			if(delay_cnt == 20'd255)	//延时然后进入空闲状态
				next_state <= S_IDLE;
			else
				next_state <= S_CE_LOW;
		default:next_state <= S_IDLE;
	endcase
end

//片选信号控制
always@(posedge clk or posedge rst_n)
begin
	if(rst_n)
		CS_reg <= 1'b0;
	else if(state == S_CE_HIGH)
		CS_reg <= 1'b1;
	else if(state == S_CE_LOW)
		CS_reg <= 1'b0;
end

//片选信号改变后延时
always@(posedge clk or posedge rst_n)
begin
	if(rst_n)
		delay_cnt <= 20'd0;
	else if(state == S_CE_HIGH || state == S_CE_LOW)
		delay_cnt <= delay_cnt + 20'd1;
	else
		delay_cnt <= 20'd0;
end

//配置SPI请求触发信号
always@(posedge clk or posedge rst_n)
begin
	if(rst_n)
		wr_req <= 1'b0;
	else if(wr_ack)
		wr_req <= 1'b0;
	else if(state == S_READ_ADDR || state == S_READ_DATA || state == S_WRITE_ADDR || state == S_WRITE_DATA)
		wr_req <= 1'b1;	//该四种状态需要触发SPI驱动
end

//改变数据口方向
always@(posedge clk or posedge rst_n)
begin
	if(rst_n)
		ds1302_io_dir <= 1'b0;
	else
		ds1302_io_dir <= (state == S_READ_DATA);
end

//将SPI驱动模块读到的数据输出
always@(posedge clk or posedge rst_n)
begin
	if(rst_n)
		read_data <= 8'h00;
	else if(state == S_READ_DATA && wr_ack)
		read_data <= {data_rec[0],data_rec[1],data_rec[2],data_rec[3],data_rec[4],data_rec[5],data_rec[6],data_rec[7]};	//把读到的数据高低位反转，因为实际先读
end

//把要写的地址或数据传给SPI驱动模块的输入
always@(posedge clk or posedge rst_n)
begin
	if(rst_n)
		send_data <= 8'h00;
	else if(state == S_READ_ADDR)	//低位在前高位在后，先写低位
		send_data <= {1'b1,read_addr[1],read_addr[2],read_addr[3],read_addr[4],read_addr[5],read_addr[6],1'b1};
	else if(state == S_WRITE_ADDR)
		send_data <= {1'b0,write_addr[1],write_addr[2],write_addr[3],write_addr[4],write_addr[5],write_addr[6],1'b1};
	else if(state == S_WRITE_DATA)
		send_data <= {write_data[0],write_data[1],write_data[2],write_data[3],write_data[4],write_data[5],write_data[6],write_data[7]};
end

//实例化SPI驱动模块
spi_master spi_master_m0(
	.clk(clk),
	.rst_n(rst_n),
	.nCS(ds1302_ce),
	.DCLK(DCLK),
	.MOSI(MOSI),
	.MISO(MISO),
	.CPOL(1'b0),
	.CPHA(1'b0),
	.nCS_ctrl(CS_reg),
	.clk_div(16'd50),
	.wr_req(wr_req),
	.wr_ack(wr_ack),
	.data_in(send_data),
	.data_out(data_rec)
);
endmodule
